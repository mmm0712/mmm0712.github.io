<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合</title>
      <link href="/2021/08/28/Java%E9%9B%86%E5%90%88/"/>
      <url>/2021/08/28/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc?x-oss-process=image/format,png" alt="java集合"></p><h3 id="框架底层数据结构"><a href="#框架底层数据结构" class="headerlink" title="框架底层数据结构"></a>框架底层数据结构</h3><ol><li>List</li></ol><ul><li><p>  ArrayList：数组</p></li><li><p>  LinkedList：双向循环链表</p></li><li><p>  Vector：数组</p></li></ul><ol start="2"><li>Set</li></ol><ul><li><p>  HashSet：基于 HashMap 实现的，底层采用 HashMap 来保存元素</p></li><li><p>  LinkedHashSet：LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</p></li><li><p>  TreeSet：红黑树（自平衡的排序二叉树）</p></li></ul><ol start="3"><li>Map</li></ol><ul><li><p>  HashMap：JDK1.8之前：哈希表（数组+单向链表）；JDK1.8之后：哈希表（数组+单向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p></li><li><p>  LinkedHashMap：JDK1.8之前：哈希表（数组+双向链表）；JDK1.8之后：哈希表（数组+双向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p></li><li><p>  HashTable：哈希表</p></li><li><p>  TreeMap：红黑树</p></li></ul><h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><ul><li><p>  数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p></li><li><p>  随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li><p>  增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p></li><li><p>  内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p></li><li><p>  线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><blockquote><p>Tips:</p><ul><li><p>  ArrayList是线程不安全的</p></li><li><p> 可以保存null元素</p></li><li><p> indexOf(Object o)方法的作用是从头开始查找与指定元素相等的元素</p></li><li><p> 实现了RandomAccess接口，支持随机访问，通过get(i)即可获得相应内存中存放的值</p></li></ul></blockquote><h3 id="ArrayList的线程不安全"><a href="#ArrayList的线程不安全" class="headerlink" title="ArrayList的线程不安全"></a>ArrayList的线程不安全</h3><p><a href="https://blog.csdn.net/u012859681/article/details/78206494?ops_request_misc=&request_id=&biz_id=102&utm_term=ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-78206494.pc_search_em_sort&spm=1018.2226.3001.4187">详细解析</a></p><h3 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h3><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h3 id="HashMap在JDK1-7和1-8中的底层实现的不同"><a href="#HashMap在JDK1-7和1-8中的底层实现的不同" class="headerlink" title="HashMap在JDK1.7和1.8中的底层实现的不同"></a>HashMap在JDK1.7和1.8中的底层实现的不同</h3><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://img-blog.csdnimg.cn/2019121422243983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"></p><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://img-blog.csdnimg.cn/20191214222452844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"></p><p>优化：</p><ol><li><p>resize 扩容优化</p></li><li><p>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</p></li><li><p>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</p></li></ol><h3 id="HashMap如何解决哈希冲突"><a href="#HashMap如何解决哈希冲突" class="headerlink" title="HashMap如何解决哈希冲突"></a>HashMap如何解决哈希冲突</h3><p><strong>哈希冲突</strong>：当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><ol><li><p>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</p></li><li><p>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</p></li><li><p>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</p></li></ol><h3 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h3 id="HashMap的线程不安全"><a href="#HashMap的线程不安全" class="headerlink" title="HashMap的线程不安全"></a>HashMap的线程不安全</h3><ol><li>put的时候导致的多线程数据不一致。</li></ol><p>这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p><ol start="2"><li>另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%）<a href="https://blog.csdn.net/weixin_30326745/article/details/95859533?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164068269016780261974611%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164068269016780261974611&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-95859533.pc_search_em_sort&utm_term=%E5%A4%9A%E7%BA%BF%E7%A8%8BHashMap%E7%9A%84resize&spm=1018.2226.3001.4187">详细分析</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
            <tag> ArrayList </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架</title>
      <link href="/2021/06/14/SpringMVC%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/06/14/SpringMVC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>JavaEE体系结构包括四层，从上到下分别是应用层、Web层、业务层、持久层。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。</p><h1 id="一、什么是SpringMVC？"><a href="#一、什么是SpringMVC？" class="headerlink" title="一、什么是SpringMVC？"></a>一、什么是SpringMVC？</h1><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h1 id="二、SpringMVC的工作流程"><a href="#二、SpringMVC的工作流程" class="headerlink" title="二、SpringMVC的工作流程"></a>二、SpringMVC的工作流程</h1><p><img src="https://img-blog.csdnimg.cn/20200202103741480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmZWlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="SpingMVC工作流程"></p><p><strong>具体流程</strong></p><p>（1）首先浏览器发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p><p>（2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；</p><p>（3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p><p>（4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p><p>（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；</p><p>（6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；</p><p>（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p><h1 id="三、SpringMVC的优点"><a href="#三、SpringMVC的优点" class="headerlink" title="三、SpringMVC的优点"></a>三、SpringMVC的优点</h1><blockquote><ul><li><p>  可以支持各种视图技术,而不仅仅局限于JSP；</p></li><li><p>  与Spring框架集成（如IoC容器、AOP等）；</p></li><li><p>  清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）；</p></li><li><p>  支持各种请求资源的映射策略</p></li></ul></blockquote><h1 id="四、SpringMVC常用注解"><a href="#四、SpringMVC常用注解" class="headerlink" title="四、SpringMVC常用注解"></a>四、SpringMVC常用注解</h1><p><strong>@RequestMapping：</strong><br>用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p><strong>@RequestBody：</strong><br>注解实现接收http请求的json数据，将json转换为java对象。</p><p><strong>@ResponseBody：</strong><br>注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h1 id="五、SpringMVC和Struts2的区别"><a href="#五、SpringMVC和Struts2的区别" class="headerlink" title="五、SpringMVC和Struts2的区别"></a>五、SpringMVC和Struts2的区别</h1><ul><li>  springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</li></ul><ul><li>  springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li></ul><ul><li>  Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2021/06/13/Spring/"/>
      <url>/2021/06/13/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Spring框架的模块组成"><a href="#一、Spring框架的模块组成" class="headerlink" title="一、Spring框架的模块组成"></a>一、Spring框架的模块组成</h1><p>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。<br><img src="https://img-blog.csdnimg.cn/20200202212938740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmZWlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="Spring框架"><br>Spring 官网列出的 Spring 的 6 个特征:</p><ul><li><p>  核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</p></li><li><p>  测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</p></li><li><p>  数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。</p></li><li><p>  Web支持 : Spring MVC和Spring WebFlux Web框架。</p></li><li><p>  集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</p></li><li><p>  语言 ：Kotlin，Groovy，动态语言</p></li></ul><p>列举一些模块：</p><ul><li><p>  Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p></li><li><p>  Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务；</p></li><li><p>  Spring AOP：AOP服务；</p></li><li><p>  Spring Web：提供了基本的面向Web的综合特性，提供对常见框架如Struts2的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器；</p></li><li><p>  Spring MVC：提供面向Web应用的Model-View-Controller，即MVC实现。</p></li><li><p>  Spring DAO：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务；</p></li><li><p>  Spring ORM：对现有的ORM框架的支持；</p></li></ul><blockquote><p>Spring的优点：</p><ol><li><p>spring属于低侵入式设计，代码的污染极低；</p></li><li><p>spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p></li><li><p>Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p></li><li><p>spring对于主流的应用框架提供了集成支持。</p></li></ol></blockquote><h1 id="二、Spring的核心原理"><a href="#二、Spring的核心原理" class="headerlink" title="二、Spring的核心原理"></a>二、Spring的核心原理</h1><p>Spring框架最核心的原理：IOC 和 AOP。IOC让相互协作的组件保持松散的耦合，而AOP编程允许把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h2 id="1、控制反转IOC"><a href="#1、控制反转IOC" class="headerlink" title="1、控制反转IOC"></a>1、控制反转IOC</h2><ul><li>  IOC就是控制反转，是指创建对象的控制权的转移，将创建对象的主动权和时机转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IOC容器来动态注入对象需要的外部资源。</li><li>  最直观的表达就是，IOC让对象的创建不用去new了，可以由Spring容器自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</li><li>  Spring的IOC常用的有三种注入方式 ：构造器注入、setter方法注入、基于注解注入（@Autowired）。<h2 id="2、面向切面AOP"><a href="#2、面向切面AOP" class="headerlink" title="2、面向切面AOP"></a>2、面向切面AOP</h2></li><li>  AOP，面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</li><li>  Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ul><h1 id="三、Spring容器中的Bean"><a href="#三、Spring容器中的Bean" class="headerlink" title="三、Spring容器中的Bean"></a>三、Spring容器中的Bean</h1><p>Bean是Spring容器中最重要的元素，Spring容器本身是一个大工厂，主要的功能就是管理好Bean，为此引入了IOC和AOP机制。</p><h2 id="1、Bean的作用域"><a href="#1、Bean的作用域" class="headerlink" title="1、Bean的作用域"></a>1、Bean的作用域</h2><p>在Spring容器中，Bean的作用域用于确定将什么类型的Bean实例返回给调用者。</p><ul><li><p>  singleton（单例）:在spring容器中仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</p></li><li><p>  prototype（原型）:每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</p></li><li><p>  request:每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  session:同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  globalSession:同一个全局 Session 共享一个 bean，用于 Portlet, 该作用域仅用于 WebApplication 环境。</p><h2 id="2、Bean的注入方式"><a href="#2、Bean的注入方式" class="headerlink" title="2、Bean的注入方式"></a>2、Bean的注入方式</h2></li></ul><ol><li><p>基于注解 @Autowired 的自动装配（最常用）</p></li><li><p>基于构造方法注入</p></li><li><p>基于Setter方法注入</p></li></ol><h2 id="3、Bean的生命周期"><a href="#3、Bean的生命周期" class="headerlink" title="3、Bean的生命周期"></a>3、Bean的生命周期</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/84341632e9df3625a91c3e2a1437ee65.png" alt="Bean的周期"></p><ol><li><p><strong>实例化Bean：</strong><br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p></li><li><p><strong>设置对象属性（依赖注入）：</strong><br>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。</p></li><li><p><strong>处理Aware接口：</strong><br>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的一些资源；</p></li><li><p><strong>BeanPostProcessor前置处理：</strong><br>如果想对Bean进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p></li><li><p><strong>InitializingBean：</strong><br>如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。</p></li><li><p><strong>init-method：</strong><br>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p></li><li><p><strong>BeanPostProcessor后置处理：</strong><br>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p></li><li><p><strong>DisposableBean：</strong><br>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p></li><li><p><strong>destroy-method：</strong><br>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p></li></ol><h2 id="4、单例Bean的线程安全和并发问题"><a href="#4、单例Bean的线程安全和并发问题" class="headerlink" title="4、单例Bean的线程安全和并发问题"></a>4、单例Bean的线程安全和并发问题</h2><ul><li>  Spring框架中的单例bean不是线程安全的。spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</li><li>  一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<h1 id="四、Spring框架中用到的设计模式"><a href="#四、Spring框架中用到的设计模式" class="headerlink" title="四、Spring框架中用到的设计模式"></a>四、Spring框架中用到的设计模式</h1></li></ul><ol><li><strong>工厂模式</strong><br>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。两者的区别：</li></ol><ul><li>  BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入)，占用更少的内存，程序启动速度更快。</li><li>  ApplicationContext ：容器启动的时候，一次性创建所有 bean 。ApplicationContext除了BeanFactory的功能，还有额外更多功能，实际开发中，ApplicationContext更常用。</li></ul><ol start="2"><li><strong>单例模式</strong><br>Spring 中 Bean 的默认作用域就是 singleton(单例)的。使用单例模式的好处：</li></ol><ul><li>  对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>  由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><ol start="3"><li><p><strong>代理模式</strong><br>pring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。</p></li><li><p><strong>模板方法</strong><br>用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate等。</p></li><li><p><strong>观察者模式</strong></p></li></ol><ul><li>  定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现：ApplicationListener。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10底部任务栏无响应怎么办？</title>
      <link href="/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
      <url>/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="win10底部任务栏无反应（鼠标一直转圈，系统假死）"><a href="#win10底部任务栏无反应（鼠标一直转圈，系统假死）" class="headerlink" title="win10底部任务栏无反应（鼠标一直转圈，系统假死）"></a>win10底部任务栏无反应（鼠标一直转圈，系统假死）</h3><blockquote><p>方法一</p><p>1、按下【ctrl+shfit+esc】打开任务管理器；</p><p>2、点击【文件】-【运行新任务】；</p><p>3、勾选【以系统管理权限创建此任务】，在框中输入：cmd ，点击确定 ；</p><p>在CMD里输入 shutdown -r -t 5（5秒后重启计算机），回车。等待重启电脑。</p></blockquote><blockquote><p>方法二</p><p>1、按下“ctrl+alt+delete”键，打开 任务管理器 ；</p><p>2、在“详细信息”中找到“explorer.exe”，选择结束任务；</p><p>3、在任务管理器中创建新任务，输入“explorer.exe”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
