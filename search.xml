<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合</title>
      <link href="/2021/08/28/Java%E9%9B%86%E5%90%88/"/>
      <url>/2021/08/28/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc?x-oss-process=image/format,png" alt="java集合"></p><h3 id="框架底层数据结构"><a href="#框架底层数据结构" class="headerlink" title="框架底层数据结构"></a>框架底层数据结构</h3><ol><li>List</li></ol><ul><li><p>  ArrayList：数组</p></li><li><p>  LinkedList：双向循环链表</p></li><li><p>  Vector：数组</p></li></ul><ol start="2"><li>Set</li></ol><ul><li><p>  HashSet：基于 HashMap 实现的，底层采用 HashMap 来保存元素</p></li><li><p>  LinkedHashSet：LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</p></li><li><p>  TreeSet：红黑树（自平衡的排序二叉树）</p></li></ul><ol start="3"><li>Map</li></ol><ul><li><p>  HashMap：JDK1.8之前：哈希表（数组+单向链表）；JDK1.8之后：哈希表（数组+单向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p></li><li><p>  LinkedHashMap：JDK1.8之前：哈希表（数组+双向链表）；JDK1.8之后：哈希表（数组+双向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p></li><li><p>  HashTable：哈希表</p></li><li><p>  TreeMap：红黑树</p></li></ul><h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><ul><li><p>  数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p></li><li><p>  随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li><p>  增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p></li><li><p>  内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p></li><li><p>  线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><blockquote><p>Tips:</p><ul><li><p>  ArrayList是线程不安全的</p></li><li><p> 可以保存null元素</p></li><li><p> indexOf(Object o)方法的作用是从头开始查找与指定元素相等的元素</p></li><li><p> 实现了RandomAccess接口，支持随机访问，通过get(i)即可获得相应内存中存放的值</p></li></ul></blockquote><h3 id="ArrayList的线程不安全"><a href="#ArrayList的线程不安全" class="headerlink" title="ArrayList的线程不安全"></a>ArrayList的线程不安全</h3><p><a href="https://blog.csdn.net/u012859681/article/details/78206494?ops_request_misc=&request_id=&biz_id=102&utm_term=ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-78206494.pc_search_em_sort&spm=1018.2226.3001.4187">详细解析</a></p><h3 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h3><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h3 id="HashMap在JDK1-7和1-8中的底层实现的不同"><a href="#HashMap在JDK1-7和1-8中的底层实现的不同" class="headerlink" title="HashMap在JDK1.7和1.8中的底层实现的不同"></a>HashMap在JDK1.7和1.8中的底层实现的不同</h3><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://img-blog.csdnimg.cn/2019121422243983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"></p><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://img-blog.csdnimg.cn/20191214222452844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"></p><p>优化：</p><ol><li><p>resize 扩容优化</p></li><li><p>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</p></li><li><p>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</p></li></ol><h3 id="HashMap如何解决哈希冲突"><a href="#HashMap如何解决哈希冲突" class="headerlink" title="HashMap如何解决哈希冲突"></a>HashMap如何解决哈希冲突</h3><p><strong>哈希冲突</strong>：当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><ol><li><p>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</p></li><li><p>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</p></li><li><p>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</p></li></ol><h3 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h3 id="HashMap的线程不安全"><a href="#HashMap的线程不安全" class="headerlink" title="HashMap的线程不安全"></a>HashMap的线程不安全</h3><ol><li>put的时候导致的多线程数据不一致。</li></ol><p>这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p><ol start="2"><li>另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%）<a href="https://blog.csdn.net/weixin_30326745/article/details/95859533?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164068269016780261974611%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164068269016780261974611&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-95859533.pc_search_em_sort&utm_term=%E5%A4%9A%E7%BA%BF%E7%A8%8BHashMap%E7%9A%84resize&spm=1018.2226.3001.4187">详细分析</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
            <tag> ArrayList </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架</title>
      <link href="/2021/06/14/SpringMVC%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/06/14/SpringMVC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>JavaEE体系结构包括四层，从上到下分别是应用层、Web层、业务层、持久层。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。</p><h1 id="一、什么是SpringMVC？"><a href="#一、什么是SpringMVC？" class="headerlink" title="一、什么是SpringMVC？"></a>一、什么是SpringMVC？</h1><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h1 id="二、SpringMVC的工作流程"><a href="#二、SpringMVC的工作流程" class="headerlink" title="二、SpringMVC的工作流程"></a>二、SpringMVC的工作流程</h1><p><img src="https://img-blog.csdnimg.cn/20200202103741480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmZWlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="SpingMVC工作流程"></p><p><strong>具体流程</strong></p><p>（1）首先浏览器发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p><p>（2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；</p><p>（3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p><p>（4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p><p>（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；</p><p>（6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；</p><p>（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p><h1 id="三、SpringMVC的优点"><a href="#三、SpringMVC的优点" class="headerlink" title="三、SpringMVC的优点"></a>三、SpringMVC的优点</h1><blockquote><ul><li><p>  可以支持各种视图技术,而不仅仅局限于JSP；</p></li><li><p>  与Spring框架集成（如IoC容器、AOP等）；</p></li><li><p>  清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）；</p></li><li><p>  支持各种请求资源的映射策略</p></li></ul></blockquote><h1 id="四、SpringMVC常用注解"><a href="#四、SpringMVC常用注解" class="headerlink" title="四、SpringMVC常用注解"></a>四、SpringMVC常用注解</h1><p><strong>@RequestMapping：</strong><br>用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p><strong>@RequestBody：</strong><br>注解实现接收http请求的json数据，将json转换为java对象。</p><p><strong>@ResponseBody：</strong><br>注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h1 id="五、SpringMVC和Struts2的区别"><a href="#五、SpringMVC和Struts2的区别" class="headerlink" title="五、SpringMVC和Struts2的区别"></a>五、SpringMVC和Struts2的区别</h1><ul><li>  springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</li></ul><ul><li>  springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li></ul><ul><li>  Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2021/06/13/Spring/"/>
      <url>/2021/06/13/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Spring框架的模块组成"><a href="#一、Spring框架的模块组成" class="headerlink" title="一、Spring框架的模块组成"></a>一、Spring框架的模块组成</h1><p>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。<br><img src="https://img-blog.csdnimg.cn/20200202212938740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmZWlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="Spring框架"><br>Spring 官网列出的 Spring 的 6 个特征:</p><ul><li><p>  核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</p></li><li><p>  测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</p></li><li><p>  数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。</p></li><li><p>  Web支持 : Spring MVC和Spring WebFlux Web框架。</p></li><li><p>  集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</p></li><li><p>  语言 ：Kotlin，Groovy，动态语言</p></li></ul><p>列举一些模块：</p><ul><li><p>  Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p></li><li><p>  Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务；</p></li><li><p>  Spring AOP：AOP服务；</p></li><li><p>  Spring Web：提供了基本的面向Web的综合特性，提供对常见框架如Struts2的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器；</p></li><li><p>  Spring MVC：提供面向Web应用的Model-View-Controller，即MVC实现。</p></li><li><p>  Spring DAO：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务；</p></li><li><p>  Spring ORM：对现有的ORM框架的支持；</p></li></ul><blockquote><p>Spring的优点：</p><ol><li><p>spring属于低侵入式设计，代码的污染极低；</p></li><li><p>spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p></li><li><p>Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p></li><li><p>spring对于主流的应用框架提供了集成支持。</p></li></ol></blockquote><h1 id="二、Spring的核心原理"><a href="#二、Spring的核心原理" class="headerlink" title="二、Spring的核心原理"></a>二、Spring的核心原理</h1><p>Spring框架最核心的原理：IOC 和 AOP。IOC让相互协作的组件保持松散的耦合，而AOP编程允许把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h2 id="1、控制反转IOC"><a href="#1、控制反转IOC" class="headerlink" title="1、控制反转IOC"></a>1、控制反转IOC</h2><ul><li>  IOC就是控制反转，是指创建对象的控制权的转移，将创建对象的主动权和时机转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IOC容器来动态注入对象需要的外部资源。</li><li>  最直观的表达就是，IOC让对象的创建不用去new了，可以由Spring容器自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</li><li>  Spring的IOC常用的有三种注入方式 ：构造器注入、setter方法注入、基于注解注入（@Autowired）。<h2 id="2、面向切面AOP"><a href="#2、面向切面AOP" class="headerlink" title="2、面向切面AOP"></a>2、面向切面AOP</h2></li><li>  AOP，面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</li><li>  Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ul><h1 id="三、Spring容器中的Bean"><a href="#三、Spring容器中的Bean" class="headerlink" title="三、Spring容器中的Bean"></a>三、Spring容器中的Bean</h1><p>Bean是Spring容器中最重要的元素，Spring容器本身是一个大工厂，主要的功能就是管理好Bean，为此引入了IOC和AOP机制。</p><h2 id="1、Bean的作用域"><a href="#1、Bean的作用域" class="headerlink" title="1、Bean的作用域"></a>1、Bean的作用域</h2><p>在Spring容器中，Bean的作用域用于确定将什么类型的Bean实例返回给调用者。</p><ul><li><p>  singleton（单例）:在spring容器中仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</p></li><li><p>  prototype（原型）:每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</p></li><li><p>  request:每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  session:同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  globalSession:同一个全局 Session 共享一个 bean，用于 Portlet, 该作用域仅用于 WebApplication 环境。</p><h2 id="2、Bean的注入方式"><a href="#2、Bean的注入方式" class="headerlink" title="2、Bean的注入方式"></a>2、Bean的注入方式</h2></li></ul><ol><li><p>基于注解 @Autowired 的自动装配（最常用）</p></li><li><p>基于构造方法注入</p></li><li><p>基于Setter方法注入</p></li></ol><h2 id="3、Bean的生命周期"><a href="#3、Bean的生命周期" class="headerlink" title="3、Bean的生命周期"></a>3、Bean的生命周期</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/84341632e9df3625a91c3e2a1437ee65.png" alt="Bean的周期"></p><ol><li><p><strong>实例化Bean：</strong><br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p></li><li><p><strong>设置对象属性（依赖注入）：</strong><br>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。</p></li><li><p><strong>处理Aware接口：</strong><br>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的一些资源；</p></li><li><p><strong>BeanPostProcessor前置处理：</strong><br>如果想对Bean进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p></li><li><p><strong>InitializingBean：</strong><br>如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。</p></li><li><p><strong>init-method：</strong><br>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p></li><li><p><strong>BeanPostProcessor后置处理：</strong><br>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p></li><li><p><strong>DisposableBean：</strong><br>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p></li><li><p><strong>destroy-method：</strong><br>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p></li></ol><h2 id="4、单例Bean的线程安全和并发问题"><a href="#4、单例Bean的线程安全和并发问题" class="headerlink" title="4、单例Bean的线程安全和并发问题"></a>4、单例Bean的线程安全和并发问题</h2><ul><li>  Spring框架中的单例bean不是线程安全的。spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</li><li>  一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<h1 id="四、Spring框架中用到的设计模式"><a href="#四、Spring框架中用到的设计模式" class="headerlink" title="四、Spring框架中用到的设计模式"></a>四、Spring框架中用到的设计模式</h1></li></ul><ol><li><strong>工厂模式</strong><br>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。两者的区别：</li></ol><ul><li>  BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入)，占用更少的内存，程序启动速度更快。</li><li>  ApplicationContext ：容器启动的时候，一次性创建所有 bean 。ApplicationContext除了BeanFactory的功能，还有额外更多功能，实际开发中，ApplicationContext更常用。</li></ul><ol start="2"><li><strong>单例模式</strong><br>Spring 中 Bean 的默认作用域就是 singleton(单例)的。使用单例模式的好处：</li></ol><ul><li>  对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>  由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><ol start="3"><li><p><strong>代理模式</strong><br>pring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。</p></li><li><p><strong>模板方法</strong><br>用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate等。</p></li><li><p><strong>观察者模式</strong></p></li></ol><ul><li>  定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现：ApplicationListener。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10底部任务栏无响应怎么办？</title>
      <link href="/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
      <url>/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="win10底部任务栏无反应（鼠标一直转圈，系统假死）"><a href="#win10底部任务栏无反应（鼠标一直转圈，系统假死）" class="headerlink" title="win10底部任务栏无反应（鼠标一直转圈，系统假死）"></a>win10底部任务栏无反应（鼠标一直转圈，系统假死）</h3><blockquote><p>方法一</p><p>1、按下【ctrl+shfit+esc】打开任务管理器；</p><p>2、点击【文件】-【运行新任务】；</p><p>3、勾选【以系统管理权限创建此任务】，在框中输入：cmd ，点击确定 ；</p><p>在CMD里输入 shutdown -r -t 5（5秒后重启计算机），回车。等待重启电脑。</p></blockquote><blockquote><p>方法二</p><p>1、按下“ctrl+alt+delete”键，打开 任务管理器 ；</p><p>2、在“详细信息”中找到“explorer.exe”，选择结束任务；</p><p>3、在任务管理器中创建新任务，输入“explorer.exe”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2021/05/28/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/05/28/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h1><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><h1 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h1><blockquote><ul><li><p>  简单易学</p></li><li><p>  面向对象：封装、继承、多态</p></li><li><p>  平台无关：Java虚拟机实现平台无关</p></li><li><p>  支持网络编程</p></li><li><p>  支持多线程</p></li><li><p>  健壮性：Java语言的强类型机制、异常处理、垃圾自动回收等</p></li><li><p>  安全性</p></li></ul></blockquote><h1 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h1><h2 id="1-标识符与关键字"><a href="#1-标识符与关键字" class="headerlink" title="1. 标识符与关键字"></a>1. 标识符与关键字</h2><p>具体参考这篇<a href="https://blog.csdn.net/weixin_38298616/article/details/81111747?ops_request_misc=&request_id=&biz_id=102&utm_term=java%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81111747.pc_search_mgc_flag&spm=1018.2226.3001.4187">文章</a></p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>具体参考这篇<a href="https://blog.csdn.net/qq_42225047/article/details/107094715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164051290016780269873488%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164051290016780269873488&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107094715.pc_search_mgc_flag&utm_term=java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&spm=1018.2226.3001.4187">文章</a></p><blockquote><ol><li>float f=3.4;是否正确</li></ol><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;</p><ol start="2"><li>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</li></ol><p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p></blockquote><h2 id="3-编码"><a href="#3-编码" class="headerlink" title="3. 编码"></a>3. 编码</h2><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><h2 id="4-访问修饰符"><a href="#4-访问修饰符" class="headerlink" title="4. 访问修饰符"></a>4. 访问修饰符</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc?x-oss-process=image/format,png" alt="访问修饰符"></p><ul><li><p>  private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p></li><li><p>  default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p></li><li><p>  protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p></li><li><p>  public : 对所有类可见。使用对象：类、接口、变量、方法</p></li></ul><h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h2><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><p>逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h2 id="6-关键字"><a href="#6-关键字" class="headerlink" title="6. 关键字"></a>6. 关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li><p>  被final修饰的类不可以被继承</p></li><li><p>  被final修饰的方法不可以被重写</p></li><li><p>  被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</p></li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol><li>普通的直接引用，this相当于是指向当前对象本身。</li></ol><ol start="2"><li>形参与成员名字重名，用this来区分：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>引用本类的构造函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ol><li>普通的直接引用</li></ol><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><ol start="2"><li>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    protected String name;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public Student(String name, String name1) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void getInfo()&#123;</span><br><span class="line">        System.out.println(this.name);      //Child</span><br><span class="line">        System.out.println(super.name);     //Father</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Student s1 = new Student(&quot;Father&quot;,&quot;Child&quot;);</span><br><span class="line">       s1.getInfo();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>引用父类构造函数</li></ol><ul><li><p>  super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p></li><li><p>  this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p></li></ul><h3 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h3><ul><li><p>  super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</p></li><li><p>  this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</p></li><li><p>  super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</p></li><li><p>  super()和this()均需放在构造方法内第一行。</p></li><li><p>  尽管可以用this调用一个构造器，但却不能调用两个。</p></li><li><p>  this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p></li><li><p>  this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</p></li><li><p>  从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</p></li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h2 id="7-流程控制语句"><a href="#7-流程控制语句" class="headerlink" title="7. 流程控制语句"></a>7. 流程控制语句</h2><h3 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h3><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><h3 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h3><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ok:</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);</span><br><span class="line">            if (j == 5) &#123;</span><br><span class="line">                break ok;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h1><h2 id="1-面向对象和面向过程"><a href="#1-面向对象和面向过程" class="headerlink" title="1. 面向对象和面向过程"></a>1. 面向对象和面向过程</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p><p>缺点：没有面向对象易维护、易复用、易扩展</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><p><strong>封装</strong></p><p>：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p><strong>继承</strong></p><p>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。继承是多态的前提。</p><blockquote><ol><li><p>子类拥有父类非 private 的属性和方法。</p></li><li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。</p></li></ol></blockquote><p><strong>多态</strong></p><p>：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ul><li><p>  方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</p></li><li><p>  对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p></li></ul><h3 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><ul><li><p>  继承：在多态中必须存在有继承关系的子类和父类。</p></li><li><p>  重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p></li><li><p>  向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p></li></ul><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><ul><li>  对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</li></ul><h3 id="面向对象的五大原则"><a href="#面向对象的五大原则" class="headerlink" title="面向对象的五大原则"></a>面向对象的五大原则</h3><ul><li><p>  单一职责原则SRP(Single Responsibility Principle)：类的功能要单一，不能包罗万象，跟杂货铺似的。</p></li><li><p>  开放封闭原则OCP(Open－Close Principle)：一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p></li><li><p>  里式替换原则LSP(the Liskov Substitution Principle LSP)：子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</p></li><li><p>  依赖倒置原则DIP(the Dependency Inversion Principle DIP)：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p></li><li><p>  接口分离原则ISP(the Interface Segregation Principle ISP)：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
