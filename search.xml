<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringMVC框架</title>
      <link href="/2021/12/14/SpringMVC%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/12/14/SpringMVC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>JavaEE体系结构包括四层，从上到下分别是应用层、Web层、业务层、持久层。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。</p><h1 id="一、什么是SpringMVC？"><a href="#一、什么是SpringMVC？" class="headerlink" title="一、什么是SpringMVC？"></a>一、什么是SpringMVC？</h1><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h1 id="二、SpringMVC的工作流程"><a href="#二、SpringMVC的工作流程" class="headerlink" title="二、SpringMVC的工作流程"></a>二、SpringMVC的工作流程</h1><p><img src="https://img-blog.csdnimg.cn/20200202103741480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmZWlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="SpingMVC工作流程"></p><p><strong>具体流程</strong></p><p>（1）首先浏览器发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p><p>（2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；</p><p>（3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p><p>（4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p><p>（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；</p><p>（6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；</p><p>（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p><h1 id="三、SpringMVC的优点"><a href="#三、SpringMVC的优点" class="headerlink" title="三、SpringMVC的优点"></a>三、SpringMVC的优点</h1><blockquote><ul><li><p>  可以支持各种视图技术,而不仅仅局限于JSP；</p></li><li><p>  与Spring框架集成（如IoC容器、AOP等）；</p></li><li><p>  清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）；</p></li><li><p>  支持各种请求资源的映射策略</p></li></ul></blockquote><h1 id="四、SpringMVC常用注解"><a href="#四、SpringMVC常用注解" class="headerlink" title="四、SpringMVC常用注解"></a>四、SpringMVC常用注解</h1><p><strong>@RequestMapping：</strong><br>用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p><strong>@RequestBody：</strong><br>注解实现接收http请求的json数据，将json转换为java对象。</p><p><strong>@ResponseBody：</strong><br>注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h1 id="五、SpringMVC和Struts2的区别"><a href="#五、SpringMVC和Struts2的区别" class="headerlink" title="五、SpringMVC和Struts2的区别"></a>五、SpringMVC和Struts2的区别</h1><ul><li>  springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</li></ul><ul><li>  springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li></ul><ul><li>  Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> -SpringMVC -java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2021/06/13/Spring/"/>
      <url>/2021/06/13/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Spring框架的模块组成"><a href="#一、Spring框架的模块组成" class="headerlink" title="一、Spring框架的模块组成"></a>一、Spring框架的模块组成</h1><p>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。<br><img src="https://img-blog.csdnimg.cn/20200202212938740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmZWlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="Spring框架"><br>Spring 官网列出的 Spring 的 6 个特征:</p><ul><li><p>  核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</p></li><li><p>  测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</p></li><li><p>  数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。</p></li><li><p>  Web支持 : Spring MVC和Spring WebFlux Web框架。</p></li><li><p>  集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</p></li><li><p>  语言 ：Kotlin，Groovy，动态语言</p></li></ul><p>列举一些模块：</p><ul><li><p>  Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p></li><li><p>  Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务；</p></li><li><p>  Spring AOP：AOP服务；</p></li><li><p>  Spring Web：提供了基本的面向Web的综合特性，提供对常见框架如Struts2的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器；</p></li><li><p>  Spring MVC：提供面向Web应用的Model-View-Controller，即MVC实现。</p></li><li><p>  Spring DAO：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务；</p></li><li><p>  Spring ORM：对现有的ORM框架的支持；</p></li></ul><blockquote><p>Spring的优点：</p><ol><li><p>spring属于低侵入式设计，代码的污染极低；</p></li><li><p>spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p></li><li><p>Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p></li><li><p>spring对于主流的应用框架提供了集成支持。</p></li></ol></blockquote><h1 id="二、Spring的核心原理"><a href="#二、Spring的核心原理" class="headerlink" title="二、Spring的核心原理"></a>二、Spring的核心原理</h1><p>Spring框架最核心的原理：IOC 和 AOP。IOC让相互协作的组件保持松散的耦合，而AOP编程允许把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h2 id="1、控制反转IOC"><a href="#1、控制反转IOC" class="headerlink" title="1、控制反转IOC"></a>1、控制反转IOC</h2><ul><li>  IOC就是控制反转，是指创建对象的控制权的转移，将创建对象的主动权和时机转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IOC容器来动态注入对象需要的外部资源。</li><li>  最直观的表达就是，IOC让对象的创建不用去new了，可以由Spring容器自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</li><li>  Spring的IOC常用的有三种注入方式 ：构造器注入、setter方法注入、基于注解注入（@Autowired）。<h2 id="2、面向切面AOP"><a href="#2、面向切面AOP" class="headerlink" title="2、面向切面AOP"></a>2、面向切面AOP</h2></li><li>  AOP，面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</li><li>  Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ul><h1 id="三、Spring容器中的Bean"><a href="#三、Spring容器中的Bean" class="headerlink" title="三、Spring容器中的Bean"></a>三、Spring容器中的Bean</h1><p>Bean是Spring容器中最重要的元素，Spring容器本身是一个大工厂，主要的功能就是管理好Bean，为此引入了IOC和AOP机制。</p><h2 id="1、Bean的作用域"><a href="#1、Bean的作用域" class="headerlink" title="1、Bean的作用域"></a>1、Bean的作用域</h2><p>在Spring容器中，Bean的作用域用于确定将什么类型的Bean实例返回给调用者。</p><ul><li><p>  singleton（单例）:在spring容器中仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</p></li><li><p>  prototype（原型）:每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</p></li><li><p>  request:每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  session:同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  globalSession:同一个全局 Session 共享一个 bean，用于 Portlet, 该作用域仅用于 WebApplication 环境。</p><h2 id="2、Bean的注入方式"><a href="#2、Bean的注入方式" class="headerlink" title="2、Bean的注入方式"></a>2、Bean的注入方式</h2></li></ul><ol><li><p>基于注解 @Autowired 的自动装配（最常用）</p></li><li><p>基于构造方法注入</p></li><li><p>基于Setter方法注入</p></li></ol><h2 id="3、Bean的生命周期"><a href="#3、Bean的生命周期" class="headerlink" title="3、Bean的生命周期"></a>3、Bean的生命周期</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/84341632e9df3625a91c3e2a1437ee65.png" alt="Bean的周期"></p><ol><li><p><strong>实例化Bean：</strong><br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p></li><li><p><strong>设置对象属性（依赖注入）：</strong><br>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。</p></li><li><p><strong>处理Aware接口：</strong><br>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的一些资源；</p></li><li><p><strong>BeanPostProcessor前置处理：</strong><br>如果想对Bean进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p></li><li><p><strong>InitializingBean：</strong><br>如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。</p></li><li><p><strong>init-method：</strong><br>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p></li><li><p><strong>BeanPostProcessor后置处理：</strong><br>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p></li><li><p><strong>DisposableBean：</strong><br>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p></li><li><p><strong>destroy-method：</strong><br>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p></li></ol><h2 id="4、单例Bean的线程安全和并发问题"><a href="#4、单例Bean的线程安全和并发问题" class="headerlink" title="4、单例Bean的线程安全和并发问题"></a>4、单例Bean的线程安全和并发问题</h2><ul><li>  Spring框架中的单例bean不是线程安全的。spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</li><li>  一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<h1 id="四、Spring框架中用到的设计模式"><a href="#四、Spring框架中用到的设计模式" class="headerlink" title="四、Spring框架中用到的设计模式"></a>四、Spring框架中用到的设计模式</h1></li></ul><ol><li><strong>工厂模式</strong><br>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。两者的区别：</li></ol><ul><li>  BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入)，占用更少的内存，程序启动速度更快。</li><li>  ApplicationContext ：容器启动的时候，一次性创建所有 bean 。ApplicationContext除了BeanFactory的功能，还有额外更多功能，实际开发中，ApplicationContext更常用。</li></ul><ol start="2"><li><strong>单例模式</strong><br>Spring 中 Bean 的默认作用域就是 singleton(单例)的。使用单例模式的好处：</li></ol><ul><li>  对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>  由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><ol start="3"><li><p><strong>代理模式</strong><br>pring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。</p></li><li><p><strong>模板方法</strong><br>用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate等。</p></li><li><p><strong>观察者模式</strong></p></li></ol><ul><li>  定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现：ApplicationListener。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10底部任务栏无响应怎么办？</title>
      <link href="/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
      <url>/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="win10底部任务栏无反应（鼠标一直转圈，系统假死）"><a href="#win10底部任务栏无反应（鼠标一直转圈，系统假死）" class="headerlink" title="win10底部任务栏无反应（鼠标一直转圈，系统假死）"></a>win10底部任务栏无反应（鼠标一直转圈，系统假死）</h3><blockquote><p>方法一</p><p>1、按下【ctrl+shfit+esc】打开任务管理器；</p><p>2、点击【文件】-【运行新任务】；</p><p>3、勾选【以系统管理权限创建此任务】，在框中输入：cmd ，点击确定 ；</p><p>在CMD里输入 shutdown -r -t 5（5秒后重启计算机），回车。等待重启电脑。</p></blockquote><blockquote><p>方法二</p><p>1、按下“ctrl+alt+delete”键，打开 任务管理器 ；</p><p>2、在“详细信息”中找到“explorer.exe”，选择结束任务；</p><p>3、在任务管理器中创建新任务，输入“explorer.exe”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
