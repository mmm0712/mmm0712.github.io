<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring</title>
      <link href="/2021/06/13/Spring/"/>
      <url>/2021/06/13/Spring/</url>
      
        <content type="html"><![CDATA[<p>#一、Spring框架的模块组成<br>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。<br><img src="https://img-blog.csdnimg.cn/20200202212938740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmZWlfY3Nkbg==,size_16,color_FFFFFF,t_70" alt="Spring框架"><br>Spring 官网列出的 Spring 的 6 个特征:</p><ul><li><p>  核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</p></li><li><p>  测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</p></li><li><p>  数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。</p></li><li><p>  Web支持 : Spring MVC和Spring WebFlux Web框架。</p></li><li><p>  集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</p></li><li><p>  语言 ：Kotlin，Groovy，动态语言</p></li></ul><p>列举一些模块：</p><ul><li><p>  Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p></li><li><p>  Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务；</p></li><li><p>  Spring AOP：AOP服务；</p></li><li><p>  Spring Web：提供了基本的面向Web的综合特性，提供对常见框架如Struts2的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器；</p></li><li><p>  Spring MVC：提供面向Web应用的Model-View-Controller，即MVC实现。</p></li><li><p>  Spring DAO：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务；</p></li><li><p>  Spring ORM：对现有的ORM框架的支持；</p></li></ul><blockquote><p>Spring的优点：</p><p>1.spring属于低侵入式设计，代码的污染极低；</p><p>2.spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p><p>3.Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p><p>4.spring对于主流的应用框架提供了集成支持。</p></blockquote><p>#二、Spring的核心原理<br>Spring框架最核心的原理：IOC 和 AOP。IOC让相互协作的组件保持松散的耦合，而AOP编程允许把遍布于应用各层的功能分离出来形成可重用的功能组件。<br>##1、控制反转IOC</p><ul><li>  IOC就是控制反转，是指创建对象的控制权的转移，将创建对象的主动权和时机转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IOC容器来动态注入对象需要的外部资源。</li><li>  最直观的表达就是，IOC让对象的创建不用去new了，可以由Spring容器自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</li><li>  Spring的IOC常用的有三种注入方式 ：构造器注入、setter方法注入、基于注解注入（@Autowired）。<br>##2、面向切面AOP</li><li>  AOP，面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</li><li>  Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，<br>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ul><p>#三、Spring容器中的Bean<br>Bean是Spring容器中最重要的元素，Spring容器本身是一个大工厂，主要的功能就是管理好Bean，为此引入了IOC和AOP机制。<br>##1、Bean的作用域<br>在Spring容器中，Bean的作用域用于确定将什么类型的Bean实例返回给调用者。</p><ul><li><p>  singleton（单例）:在spring容器中仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</p></li><li><p>  prototype（原型）:每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</p></li><li><p>  request:每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  session:同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的WebApplicationContext环境。</p></li><li><p>  globalSession:同一个全局 Session 共享一个 bean，用于 Portlet, 该作用域仅用于 WebApplication 环境。<br>##2、Bean的注入方式</p></li></ul><p>1.基于注解 @Autowired 的自动装配（最常用）</p><p>2.基于构造方法注入</p><p>3.基于Setter方法注入<br>##3、Bean的生命周期<br><img src="https://img-blog.csdnimg.cn/img_convert/84341632e9df3625a91c3e2a1437ee65.png" alt="Bean的周期"><br>1.<strong>实例化Bean：</strong></p><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。</p><p>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><p>2.<strong>设置对象属性（依赖注入）：</strong><br>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。</p><p>3.<strong>处理Aware接口：</strong><br>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的一些资源；</p><p>4.<strong>BeanPostProcessor前置处理：</strong><br>如果想对Bean进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p>5.<strong>InitializingBean：</strong><br>如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。</p><p>6.<strong>init-method：</strong><br>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><p>7.<strong>BeanPostProcessor后置处理：</strong><br>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><p>8.<strong>DisposableBean：</strong><br>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><p>9.<strong>destroy-method：</strong><br>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><p>##4、单例Bean的线程安全和并发问题</p><ul><li>  Spring框架中的单例bean不是线程安全的。spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</li><li>  一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<br>#四、Spring框架中用到的设计模式</li></ul><p>1.<strong>工厂模式</strong><br>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。两者的区别：</p><ul><li>  BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入)，占用更少的内存，程序启动速度更快。</li><li>  ApplicationContext ：容器启动的时候，一次性创建所有 bean 。ApplicationContext除了BeanFactory的功能，还有额外更多功能，实际开发中，ApplicationContext更常用。</li></ul><p>2.<strong>单例模式</strong><br>Spring 中 Bean 的默认作用域就是 singleton(单例)的。使用单例模式的好处：</p><ul><li>  对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>  由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p>3.<strong>代理模式</strong><br>pring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。</p><p>4.<strong>模板方法</strong><br>用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate等。</p><p>5.<strong>观察者模式</strong></p><ul><li>  定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现：ApplicationListener。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10底部任务栏无响应怎么办？</title>
      <link href="/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
      <url>/2021/06/11/win10%E5%BA%95%E9%83%A8%E4%BB%BB%E5%8A%A1%E6%A0%8F%E6%97%A0%E5%93%8D%E5%BA%94%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="win10底部任务栏无反应（鼠标一直转圈，系统假死）"><a href="#win10底部任务栏无反应（鼠标一直转圈，系统假死）" class="headerlink" title="win10底部任务栏无反应（鼠标一直转圈，系统假死）"></a>win10底部任务栏无反应（鼠标一直转圈，系统假死）</h3><blockquote><p>方法一</p><p>1、按下【ctrl+shfit+esc】打开任务管理器；</p><p>2、点击【文件】-【运行新任务】；</p><p>3、勾选【以系统管理权限创建此任务】，在框中输入：cmd ，点击确定 ；</p><p>在CMD里输入 shutdown -r -t 5（5秒后重启计算机），回车。等待重启电脑。</p></blockquote><blockquote><p>方法二</p><p>1、按下“ctrl+alt+delete”键，打开 任务管理器 ；</p><p>2、在“详细信息”中找到“explorer.exe”，选择结束任务；</p><p>3、在任务管理器中创建新任务，输入“explorer.exe”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
